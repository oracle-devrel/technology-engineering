# There are 2 entryPoints here: web and websecure, one for http, the other for https on the default public load balancer
ports:
  # Set this so that all HTTP traffic is redirected and upgraded to HTTPS
  web:
    redirections:
      entryPoint:
        to: websecure
        scheme: https
  websecure:
    # asDefault sets websecure as the default entryPoint if no entryPoint is specified in an ingressRoute
    asDefault: true

    # Be sure to set tls enabled if you are planning to use Traefik with TLS passthrough
    tls:
      enabled: false
    # By default, Traefik will discard x-forwarded-for and proxy protocol headers if the source Load Balancer ip is not trusted
    # Specify the range of trusted IPs here
#    forwardedHeaders:
#      trustedIPs:
#        - "10.0.0.0/16"
#    proxyProtocol:
#      trustedIPs:
#        - "10.0.0.0/16"


# To expose public APIs, usually a Load Balancer is used with TLS termination so that a WAF can be enforced.

# VCN Native CNI is capable of Pods as Backends feature, see https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengconfiguringloadbalancersnetworkloadbalancers-subtopic.htm#contengcreatingloadbalancer_topic_Specifying_pods_as_backends

# Do not forget to configure the Pod Readiness Gate:
# kubectl label ns traefik loadbalancer.oci.oraclecloud.com/pod-readiness-gate-inject=enabled

# Once satisfied, better create a Kustomize with the namespace definition and the label, so that GitOps principles are followed

service:
  type: LoadBalancer
  annotations:
    oci.oraclecloud.com/load-balancer-type: "lb"
    service.beta.kubernetes.io/oci-load-balancer-shape: "flexible"
    # Set suitable values for min-max bandwidth
    service.beta.kubernetes.io/oci-load-balancer-shape-flex-min: "10"
    service.beta.kubernetes.io/oci-load-balancer-shape-flex-max: "10"

    # If needed, you can specify a public subnet OCID where to create the LB. If not specified, will default to OKE service subnet
    #service.beta.kubernetes.io/oci-load-balancer-subnet1: "<subnet-OCID>"

    # Better to attach 2 NSGs, one containing only ingress rules, the other containing only egress rules
    oci.oraclecloud.com/oci-network-security-groups: "ocid1.networksecuritygroup...,ocid1.networksecuritygroup..."
    # By setting this to None, you will be in charge of writing all the security rules, CCM will not be allowed to set automatically any security rule
    oci.oraclecloud.com/security-rule-management-mode: "None"
    # Set listener to HTTP if you want to use WAF, otherwise TCP
    service.beta.kubernetes.io/oci-load-balancer-backend-protocol: "HTTP"

    # A HTTP listener will automatically put the x-forwarded-for header with the real IP address, but not the TCP listener. So we need to enable proxy protocol. By default it's disabled here, because we are forced to relay on externalTrafficPolicy: "Cluster"
    #service.beta.kubernetes.io/oci-load-balancer-connection-proxy-protocol-version: "2"

    # TLS termination. The secret must be present in the traefik namespace. Only 1 certificate is supported, and to rotate you need to create a new secret and modify this annotation
    service.beta.kubernetes.io/oci-load-balancer-ssl-ports: "443"
    service.beta.kubernetes.io/oci-load-balancer-tls-secret: "ssl-certificate-secret"
    #oci.oraclecloud.com/oci-load-balancer-listener-ssl-config: '{"CipherSuiteName":"oci-default-http2-tls-12-13-ssl-cipher-suite-v1", "Protocols":["TLSv1.3"]}'

    # Specify load balancer policy if needed, supported values are ROUND_ROBIN, LEAST_CONNECTIONS, IP_HASH
    oci.oraclecloud.com/loadbalancer-policy: "ROUND_ROBIN"
    # Connection idle timeout, for TCP listener max is 300 seconds, for HTTP max is 60 seconds
    service.beta.kubernetes.io/oci-load-balancer-connection-idle-timeout: "60"
    # For security, better limit the HTTP header size
    oci.oraclecloud.com/oci-load-balancer-rule-sets: |
      {
        "header_size": {
          "items": [
            {
              "action": "HTTP_HEADER",
              "httpLargeHeaderSizeInKB": 16
            }
          ]
        }
      }
    # Pods as Backends configuration: health check
    oci-load-balancer.oraclecloud.com/health-check: '{"protocol": "HTTP", "port": 8080, "urlPath": "/healthz", "returnCode": 200, "retries": 3, "timeoutInMillis": 2000}'
  spec:
    # We are forced to put Cluster here because of the risk of packet drops when a readiness gate is implemented.
    # Example: LB health check is OK before readiness, the packet will be forwarded, but the ingress is still not available from a Kubernetes perspective.
    # Then, if the externalTrafficPolicy is Local, the packet will just be dropped, instead of being re-routed to an ingress pod in another node
    externalTrafficPolicy: "Cluster"
    # Public Reserved IP
    #loadBalancerIP: "140.121.164.12"
    # Necessary for Pods as Backends
    allocateLoadBalancerNodePorts: false